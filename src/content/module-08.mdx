import Callout from '../components/Callout.astro';
import CommandTable from '../components/CommandTable.astro';

### ¿Qué es un script de Bash?

Hasta ahora has escrito comandos uno por uno en la terminal. Un **script** es simplemente un archivo de texto que contiene una serie de comandos que se ejecutan en secuencia. En lugar de escribir 10 comandos a mano, los pones todos en un archivo y lo ejecutas una sola vez.

Piensa en un script como una receta de cocina: es una lista de instrucciones paso a paso que el computador sigue automáticamente. Los scripts son increíblemente útiles para automatizar tareas repetitivas, como hacer respaldos, procesar archivos de datos, o configurar un entorno de trabajo.

### ¿Por qué Bash si ya existe Python y R?

Si vienes del mundo de ciencia de datos, probablemente te preguntas: ¿para qué aprender Bash scripting si puedo hacer todo en Python o R? La respuesta es que **Bash no reemplaza a esos lenguajes, los coordina**. Cada uno tiene su rol:

- **Python/R**: análisis, estadísticas, modelos, visualizaciones
- **Bash**: automatizar, conectar, mover archivos, preparar datos, orquestar

En la práctica, un flujo de trabajo real de ciencia de datos se ve así:

```bash title="pipeline-datos.sh"
#!/bin/bash

echo "=== Pipeline de análisis de datos ==="
echo "Inicio: $(date)"

# 1. Descargar los datos frescos
echo "Descargando datos..."
curl -s -o datos_raw.csv https://api.ejemplo.com/datos/export

# 2. Limpiar y transformar con Python
echo "Limpiando datos con Python..."
python3 limpiar_datos.py datos_raw.csv datos_limpios.csv

# 3. Análisis estadístico con R
echo "Ejecutando análisis en R..."
Rscript analisis_estadistico.R datos_limpios.csv resultados/

# 4. Generar reporte
echo "Generando reporte..."
python3 generar_reporte.py resultados/ reporte_final.html

echo "Pipeline completado: $(date)"
echo "Reporte disponible en: reporte_final.html"
```

**Bash es el director de orquesta**: descarga datos, llama a Python para limpiarlos, llama a R para analizarlos, y junta todo. Este patrón es la forma estándar de trabajar en **Bioinformática, Data Science y DevOps**.

<Callout type="info" title="Ejemplo real: Bioinformática">
  En bioinformática, un pipeline típico ejecuta una docena de herramientas diferentes en secuencia: descarga secuencias genómicas, las alinea con una herramienta en C++, las filtra con Python, hace estadísticas con R, y genera reportes en HTML. Todo coordinado por un script de Bash. Sin Bash, tendrías que ejecutar cada paso manualmente y acordarte del orden exacto.
</Callout>

Otro ejemplo más simple pero muy útil: preparar tu entorno de trabajo cada día:

```bash title="iniciar-proyecto.sh"
#!/bin/bash

# Script para iniciar tu día de trabajo en un proyecto de datos
echo "Preparando entorno de trabajo..."

# Activar el entorno virtual de Python
source ~/envs/mi-proyecto/bin/activate

# Ir al directorio del proyecto
cd ~/proyectos/analisis-salud

# Descargar datos actualizados
echo "Descargando datos del día..."
python3 descargar_datos.py

# Abrir Jupyter Notebook
echo "Abriendo Jupyter..."
jupyter notebook &

echo "¡Todo listo! Jupyter se abrió en tu navegador."
```

En lugar de recordar y escribir 5 comandos cada mañana, ejecutas `./iniciar-proyecto.sh` y todo se prepara solo.

### Tu primer script

Vamos a crear un script simple paso a paso. Abre Nano y crea un archivo llamado `hola.sh`:

```bash
nano hola.sh
```

Escribe lo siguiente:

```bash title="hola.sh"
#!/bin/bash

# Mi primer script de Bash
echo "¡Hola desde mi script!"
echo "Hoy es $(date)"
echo "Estás en: $(pwd)"
```

Guarda con `Ctrl + O` + Enter y sal con `Ctrl + X`.

Antes de poder ejecutarlo, necesitas dos pasos:

```bash
# Paso 1: Dar permiso de ejecución
chmod +x hola.sh

# Paso 2: Ejecutar el script
./hola.sh
```

#### El shebang: `#!/bin/bash`

La primera línea `#!/bin/bash` se llama **shebang** (o hashbang). Es la línea más importante de cualquier script porque le dice al sistema operativo **qué programa debe usar para interpretar** las instrucciones que siguen.

```bash
#!/bin/bash     ← "Usa Bash para ejecutar este script"
```

Sin el shebang, el sistema podría intentar ejecutar tu script con el shell equivocado, o directamente no saber qué hacer con él. **Siempre** incluye el shebang como primera línea.

El shebang no es exclusivo de Bash. Esto es lo que hace tan poderoso el concepto: puedes tener scripts en diferentes lenguajes y el sistema sabe cómo ejecutar cada uno:

```bash
#!/bin/bash          # Script de Bash
#!/usr/bin/env python3  # Script de Python
#!/usr/bin/env Rscript  # Script de R
#!/usr/bin/env node     # Script de Node.js
```

<Callout type="tip" title="¿Por qué /usr/bin/env?">
  Para Python, R y otros lenguajes, es mejor usar `#!/usr/bin/env python3` en vez de `#!/usr/bin/python3`. La versión con `env` busca el programa en tu `PATH`, así funciona aunque Python esté instalado en una ruta diferente (como en un entorno virtual). Para Bash usamos `#!/bin/bash` directamente porque Bash siempre está en `/bin/bash` en sistemas Linux.
</Callout>

#### Rutas al ejecutar scripts: `./` y por qué importa

¿Por qué escribimos `./hola.sh` y no simplemente `hola.sh`? Este es un punto que confunde a muchos al principio, pero es fundamental entenderlo.

Cuando escribes un comando en la terminal, el sistema lo busca en una lista de carpetas predefinidas (el `PATH`). Puedes ver esas carpetas con:

```bash
echo $PATH
# /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
```

Si escribes `ls`, la terminal busca en esas carpetas, encuentra `/usr/bin/ls`, y lo ejecuta. Pero tu script `hola.sh` no está en ninguna de esas carpetas — está en tu directorio actual. Por eso necesitas decirle **explícitamente** dónde está:

```bash
# Esto NO funciona (busca hola.sh en el PATH del sistema)
hola.sh
# Error: command not found

# Esto SÍ funciona (el ./ significa "en el directorio actual")
./hola.sh

# Esto también funciona (ruta completa)
/home/paulo/scripts/hola.sh

# Y esto también (ruta relativa desde otro lugar)
../scripts/hola.sh
```

Repasemos los tipos de rutas, porque entender esto te ahorrará muchos dolores de cabeza:

**Ruta absoluta**: empieza desde la raíz del sistema (`/`). Siempre funciona sin importar dónde estés:
```bash
/home/paulo/proyectos/analisis/script.sh
/home/paulo/datos/pacientes.csv
```

**Ruta relativa**: parte desde tu directorio actual. Cambia según dónde estés:
```bash
./script.sh              # En el directorio actual
../datos/pacientes.csv   # Un nivel arriba, luego en datos/
scripts/procesar.sh      # Dentro de la subcarpeta scripts/
```

**Atajos útiles**:
```bash
.     # Directorio actual
..    # Directorio padre (un nivel arriba)
~     # Tu directorio home (/home/tu-usuario)
```

<Callout type="warning" title="Las rutas dentro de un script son relativas a DONDE lo ejecutas">
  Este es uno de los errores más comunes. Si tu script hace referencia a `datos/archivo.csv`, esa ruta es relativa **al directorio desde donde ejecutas el script**, no a donde está el script. Ejemplo:

  ```bash
  # Tu script está en ~/proyectos/scripts/procesar.sh
  # Y dentro tiene: python3 limpiar.py datos/raw.csv

  # Si lo ejecutas desde ~/proyectos/scripts/
  cd ~/proyectos/scripts/
  ./procesar.sh  # Busca datos/raw.csv dentro de scripts/ ← ¡NO EXISTE!

  # Si lo ejecutas desde ~/proyectos/
  cd ~/proyectos/
  ./scripts/procesar.sh  # Busca datos/raw.csv dentro de proyectos/ ← ¡CORRECTO!
  ```

  Para evitar este problema, usa **rutas absolutas** dentro de tus scripts, o usa este truco al inicio del script para cambiar al directorio donde está el archivo:

  ```bash
  #!/bin/bash
  # Ir al directorio donde está este script
  cd "$(dirname "$0")"
  ```
</Callout>

Veamos un ejemplo práctico. Imagina esta estructura de proyecto:

```
mi-proyecto/
├── scripts/
│   ├── limpiar.sh
│   └── analizar.sh
├── datos/
│   ├── raw/
│   │   └── encuesta.csv
│   └── procesados/
└── resultados/
```

Dentro de `limpiar.sh`, podrías escribir las rutas de dos formas:

```bash title="scripts/limpiar.sh — MAL (rutas frágiles)"
#!/bin/bash
# Esto solo funciona si ejecutas desde mi-proyecto/
python3 scripts/limpiar_datos.py datos/raw/encuesta.csv datos/procesados/encuesta_limpia.csv
```

```bash title="scripts/limpiar.sh — BIEN (rutas robustas)"
#!/bin/bash
# Primero nos ubicamos en la raíz del proyecto
cd "$(dirname "$0")/.."

# Ahora las rutas son predecibles
python3 scripts/limpiar_datos.py datos/raw/encuesta.csv datos/procesados/encuesta_limpia.csv

echo "Datos procesados en: $(pwd)/datos/procesados/"
```

La línea `cd "$(dirname "$0")/.."` hace lo siguiente:
- `$0` = la ruta con la que se llamó al script (ej: `./scripts/limpiar.sh`)
- `dirname "$0"` = el directorio donde está el script (ej: `./scripts`)
- `/.."` = subir un nivel (al directorio del proyecto)

Así el script siempre funciona sin importar desde dónde lo ejecutes.

### Variables

Las variables te permiten guardar información para usarla más adelante. En Bash, asignas una variable con el signo `=` y la usas poniendo `$` antes del nombre:

```bash title="variables.sh"
#!/bin/bash

# Asignar variables
nombre="Paulo"
edad=30
fecha=$(date +%Y-%m-%d)

# Usar variables con $
echo "Hola, $nombre"
echo "Tienes $edad años"
echo "Fecha: $fecha"

# Usar llaves para delimitar el nombre de la variable
echo "Archivo: ${nombre}_backup.txt"
```

<Callout type="warning" title="Sin espacios alrededor del =">
  En Bash, la asignación de variables **no puede tener espacios** alrededor del `=`. Esto es correcto: `nombre="Paulo"`. Esto dará error: `nombre = "Paulo"`. Es uno de los errores más comunes cuando empiezas con scripting.
</Callout>

Las llaves `${nombre}` son necesarias cuando la variable va pegada a otro texto. Sin las llaves, `$nombre_backup` buscaría una variable llamada `nombre_backup` (que no existe), en lugar de usar la variable `nombre` seguida del texto `_backup`.

#### Variables especiales

Bash tiene variables especiales que se crean automáticamente. Son especialmente útiles cuando tu script recibe información desde la línea de comandos:

| Variable | Significado |
|----------|-------------|
| `$0` | El nombre del script |
| `$1, $2, ...` | Los argumentos que le pasaste al script |
| `$#` | La cantidad de argumentos |
| `$@` | Todos los argumentos juntos |
| `$?` | El código de salida del último comando (0 = éxito, otro = error) |

Veamos cómo funcionan con un ejemplo:

```bash title="argumentos.sh"
#!/bin/bash

echo "Este script se llama: $0"
echo "Primer argumento: $1"
echo "Segundo argumento: $2"
echo "Recibí $# argumentos en total"
echo "Todos los argumentos: $@"
```

```bash
chmod +x argumentos.sh
./argumentos.sh hola mundo
# Este script se llama: ./argumentos.sh
# Primer argumento: hola
# Segundo argumento: mundo
# Recibí 2 argumentos en total
# Todos los argumentos: hola mundo
```

### Leer entrada del usuario con `read`

A veces quieres que tu script le haga preguntas al usuario y espere su respuesta. Para eso usas `read`:

```bash title="interactivo.sh"
#!/bin/bash

echo "¿Cómo te llamas?"
read nombre

echo "¿Cuántos años tienes?"
read edad

echo "¡Hola, $nombre! Tienes $edad años."
```

Puedes hacer lo mismo de forma más compacta con `read -p`, que muestra el mensaje y espera la respuesta en la misma línea:

```bash
read -p "Ingresa tu nombre: " nombre
echo "Hola, $nombre"

# Para passwords (no muestra lo que escribes)
read -sp "Ingresa tu contraseña: " password
echo  # salto de línea (porque -s oculta el Enter también)
echo "Contraseña recibida"
```

### Condicionales: tomar decisiones con `if`

Los condicionales permiten que tu script tome decisiones: "si se cumple esta condición, haz esto; si no, haz esto otro". La estructura básica es:

```bash
if [ condición ]; then
    # código si la condición es verdadera
elif [ otra_condición ]; then
    # código si la segunda condición es verdadera
else
    # código si ninguna condición se cumplió
fi
```

<Callout type="warning" title="Los espacios son obligatorios">
  Dentro de los corchetes `[ ]`, los espacios son obligatorios. `[ "$edad" -ge 18 ]` es correcto. `["$edad" -ge 18]` dará error. Esto es uno de los aspectos más confusos de Bash para principiantes, pero es una regla simple: siempre deja un espacio después de `[` y antes de `]`.
</Callout>

Veamos un ejemplo completo:

```bash title="edad.sh"
#!/bin/bash

read -p "¿Cuántos años tienes? " edad

if [ "$edad" -ge 18 ]; then
    echo "Eres mayor de edad"
elif [ "$edad" -ge 13 ]; then
    echo "Eres adolescente"
else
    echo "Eres menor de edad"
fi
```

#### Operadores de comparación para números

| Operador | Significado | Ejemplo |
|----------|-------------|---------|
| `-eq` | Igual a | `[ "$a" -eq 5 ]` |
| `-ne` | No igual a | `[ "$a" -ne 0 ]` |
| `-gt` | Mayor que | `[ "$a" -gt 10 ]` |
| `-ge` | Mayor o igual que | `[ "$a" -ge 18 ]` |
| `-lt` | Menor que | `[ "$a" -lt 0 ]` |
| `-le` | Menor o igual que | `[ "$a" -le 100 ]` |

#### Operadores para texto (strings)

| Operador | Significado | Ejemplo |
|----------|-------------|---------|
| `=` | Textos iguales | `[ "$nombre" = "Paulo" ]` |
| `!=` | Textos diferentes | `[ "$respuesta" != "no" ]` |
| `-z` | Texto vacío | `[ -z "$variable" ]` |
| `-n` | Texto no vacío | `[ -n "$variable" ]` |

#### Operadores para archivos

Estos son especialmente útiles para scripts que trabajan con archivos:

| Operador | Significado | Ejemplo |
|----------|-------------|---------|
| `-f` | Existe y es un archivo | `[ -f "datos.csv" ]` |
| `-d` | Existe y es un directorio | `[ -d "carpeta" ]` |
| `-e` | Existe (archivo o directorio) | `[ -e "algo" ]` |
| `-r` | Tiene permiso de lectura | `[ -r "archivo" ]` |
| `-w` | Tiene permiso de escritura | `[ -w "archivo" ]` |
| `-x` | Tiene permiso de ejecución | `[ -x "script.sh" ]` |

```bash title="verificar.sh"
#!/bin/bash

archivo=$1

# Verificar que se proporcionó un argumento
if [ -z "$archivo" ]; then
    echo "Uso: $0 <nombre-de-archivo>"
    echo "Ejemplo: $0 datos.csv"
    exit 1
fi

# Verificar qué es
if [ -f "$archivo" ]; then
    lineas=$(wc -l < "$archivo")
    echo "'$archivo' es un archivo con $lineas líneas"
elif [ -d "$archivo" ]; then
    echo "'$archivo' es un directorio"
else
    echo "'$archivo' no existe"
fi
```

### Bucle `for`: repetir acciones

El bucle `for` repite una acción para cada elemento de una lista. Es como decir "para cada X, haz Y":

```bash title="for-basico.sh"
#!/bin/bash

# Iterar sobre una lista de palabras
for fruta in manzana pera naranja; do
    echo "Fruta: $fruta"
done
# Fruta: manzana
# Fruta: pera
# Fruta: naranja
```

Los usos más prácticos de `for` son recorrer archivos y rangos numéricos:

```bash
# Procesar todos los archivos .txt del directorio
for archivo in *.txt; do
    echo "Procesando: $archivo"
    wc -l "$archivo"
done

# Contar del 1 al 5
for i in {1..5}; do
    echo "Número: $i"
done

# Estilo C (si vienes de otro lenguaje)
for ((i = 0; i < 5; i++)); do
    echo "Índice: $i"
done
```

#### Ejemplo práctico: renombrar archivos en lote

```bash title="renombrar.sh"
#!/bin/bash

# Renombrar todos los .txt a .md
for archivo in *.txt; do
    # Verificar que realmente hay archivos .txt
    [ -f "$archivo" ] || continue

    nuevo="${archivo%.txt}.md"
    mv "$archivo" "$nuevo"
    echo "Renombrado: $archivo → $nuevo"
done
```

La expresión `${archivo%.txt}` elimina `.txt` del final del nombre. Luego le agregamos `.md`. Es una forma muy útil de manipular nombres de archivo en Bash.

### Bucle `while`: repetir mientras se cumpla una condición

A diferencia de `for` (que recorre una lista), `while` repite una acción **mientras** una condición sea verdadera:

```bash title="while.sh"
#!/bin/bash

# Contador simple
contador=1
while [ "$contador" -le 5 ]; do
    echo "Contando: $contador"
    ((contador++))
done
```

Un uso muy práctico de `while` es leer un archivo línea por línea:

```bash
# Leer cada línea de un archivo
while IFS= read -r linea; do
    echo "Línea: $linea"
done < archivo.txt
```

#### Menú interactivo con `while` y `case`

Este es un patrón muy común en scripts de Bash: un menú que se repite hasta que el usuario elige salir:

```bash title="menu.sh"
#!/bin/bash

while true; do
    echo ""
    echo "=== MENÚ ==="
    echo "1) Mostrar fecha"
    echo "2) Listar archivos"
    echo "3) Uso de disco"
    echo "4) Salir"
    read -p "Elige una opción: " opcion

    case $opcion in
        1) date ;;
        2) ls -la ;;
        3) df -h ;;
        4) echo "¡Adiós!"; break ;;
        *) echo "Opción no válida, intenta de nuevo" ;;
    esac
done
```

`case` es la versión Bash de un "switch": compara el valor de `$opcion` con cada patrón y ejecuta el código correspondiente. El `*` es el caso por defecto (si no coincide con nada).

### Funciones: reutilizar código

Las funciones te permiten agrupar comandos bajo un nombre y reutilizarlos. Si te encuentras repitiendo el mismo bloque de código varias veces, ponlo en una función:

```bash title="funciones.sh"
#!/bin/bash

# Definir una función
saludar() {
    echo "¡Hola, $1!"
}

# Llamar a la función
saludar "Paulo"
saludar "María"
# ¡Hola, Paulo!
# ¡Hola, María!
```

Los argumentos de las funciones funcionan igual que los del script: `$1` es el primer argumento, `$2` el segundo, etc.

### Ejemplo completo: script de respaldo

Ahora vamos a juntar todo lo que aprendimos en un script útil del mundo real. Este script crea un respaldo comprimido de una carpeta:

```bash title="respaldo.sh"
#!/bin/bash

# Script de respaldo simple
# Uso: ./respaldo.sh [directorio-origen] [directorio-destino]

ORIGEN="${1:-.}"
DESTINO="${2:-./respaldo}"
FECHA=$(date +%Y%m%d_%H%M%S)
ARCHIVO="respaldo_${FECHA}.tar.gz"

# Verificar que el directorio origen existe
if [ ! -d "$ORIGEN" ]; then
    echo "Error: el directorio '$ORIGEN' no existe"
    exit 1
fi

# Crear directorio destino si no existe
mkdir -p "$DESTINO"

echo "Creando respaldo de '$ORIGEN'..."

# Crear el archivo comprimido
tar -czf "${DESTINO}/${ARCHIVO}" "$ORIGEN"

# Verificar si el comando tuvo éxito
if [ $? -eq 0 ]; then
    tamano=$(du -h "${DESTINO}/${ARCHIVO}" | cut -f1)
    echo "Respaldo creado exitosamente:"
    echo "  Archivo: ${DESTINO}/${ARCHIVO}"
    echo "  Tamaño: ${tamano}"
else
    echo "Error al crear el respaldo"
    exit 1
fi
```

```bash
chmod +x respaldo.sh
./respaldo.sh ./mi-proyecto ./backups
# Creando respaldo de './mi-proyecto'...
# Respaldo creado exitosamente:
#   Archivo: ./backups/respaldo_20260214_153000.tar.gz
#   Tamaño: 2.5M
```

Analicemos las partes nuevas:
- `${1:-.}` significa "usa el primer argumento, y si no hay ninguno, usa `.`" (directorio actual).
- `tar -czf` crea un archivo comprimido (.tar.gz). `-c` = crear, `-z` = comprimir con gzip, `-f` = nombre del archivo.
- `$?` contiene el código de salida del último comando. `0` significa éxito, cualquier otro número significa error.

### Bash como herramienta de ciencia de datos

Ya vimos cómo Bash coordina herramientas. Pero Bash también puede hacer **procesamiento de datos básico por sí solo**, sin necesidad de Python o R. Esto es útil para exploración rápida, limpieza preliminar, o cuando trabajas en un servidor sin entorno gráfico.

#### Explorar un CSV desde la terminal

```bash title="explorar-csv.sh"
#!/bin/bash

# Script para exploración rápida de un archivo CSV
archivo="${1:?Uso: $0 archivo.csv}"

if [ ! -f "$archivo" ]; then
    echo "Error: '$archivo' no existe"
    exit 1
fi

echo "=== Exploración de $archivo ==="
echo ""

# ¿Cuántas filas tiene? (restamos 1 por el encabezado)
total=$(wc -l < "$archivo")
filas=$((total - 1))
echo "Filas de datos: $filas"

# ¿Cuántas columnas?
columnas=$(head -1 "$archivo" | tr ',' '\n' | wc -l)
echo "Columnas: $columnas"

# Mostrar los nombres de las columnas
echo ""
echo "Nombres de columnas:"
head -1 "$archivo" | tr ',' '\n' | nl

# Primeras 5 filas
echo ""
echo "Primeras 5 filas:"
head -6 "$archivo" | column -t -s ','

# Tamaño del archivo
tamano=$(du -h "$archivo" | cut -f1)
echo ""
echo "Tamaño: $tamano"
```

```bash
chmod +x explorar-csv.sh
./explorar-csv.sh datos_pacientes.csv
# === Exploración de datos_pacientes.csv ===
#
# Filas de datos: 1523
# Columnas: 8
#
# Nombres de columnas:
#      1  id
#      2  nombre
#      3  edad
#      4  diagnostico
#      ...
```

#### Procesar múltiples archivos de datos

Imagina que recibes datos mensuales en archivos separados y necesitas unirlos:

```bash title="unir-datos.sh"
#!/bin/bash

# Unir múltiples CSV en uno solo (mismo formato, con encabezado)
directorio="${1:-.}"
salida="${2:-datos_combinados.csv}"

# Tomar el encabezado del primer archivo
primer_archivo=$(ls "$directorio"/*.csv 2>/dev/null | head -1)

if [ -z "$primer_archivo" ]; then
    echo "No se encontraron archivos CSV en '$directorio'"
    exit 1
fi

# Escribir encabezado
head -1 "$primer_archivo" > "$salida"

# Agregar datos de todos los archivos (sin encabezado)
for archivo in "$directorio"/*.csv; do
    tail -n +2 "$archivo" >> "$salida"
    echo "  Agregado: $archivo ($(tail -n +2 "$archivo" | wc -l) filas)"
done

total=$(tail -n +2 "$salida" | wc -l)
echo "Archivo combinado: $salida ($total filas totales)"
```

<Callout type="tip" title="¿Cuándo usar Bash vs Python para datos?">
  Usa **Bash** cuando necesites: exploración rápida (cuántas filas, qué columnas), unir/dividir archivos, renombrar archivos en lote, automatizar pipelines, descargar datos.

  Usa **Python/R** cuando necesites: análisis estadístico, limpieza compleja, visualizaciones, machine learning, manipulación avanzada de DataFrames.

  La combinación de ambos es lo más poderoso: Bash prepara y orquesta, Python/R analiza.
</Callout>

### Ejercicios del módulo

1. Crea un script `saludo.sh` que reciba un nombre como argumento (`$1`) y diga "¡Hola, [nombre]!". Si no recibe argumento, que diga "¡Hola, mundo!".
2. Crea un script `info.sh` que muestre tu usuario, la fecha, el directorio actual y cuántos archivos hay en él.
3. Crea un script que reciba un número como argumento y diga si es positivo, negativo o cero.
4. Crea un script con `read -p` que pida el nombre de un archivo y diga si existe o no (usa `[ -f "$archivo" ]`).
5. Crea un script con un bucle `for` que cree 5 archivos: `archivo1.txt`, `archivo2.txt`, ..., `archivo5.txt`.
6. Crea un script que recorra todos los archivos `.txt` del directorio actual y muestre cuántas líneas tiene cada uno.
7. Crea un menú interactivo con `while` y `case` que tenga al menos 3 opciones útiles (fecha, archivos, espacio en disco, etc.).
8. Modifica el script de respaldo del ejemplo para que muestre un mensaje de confirmación antes de crear el respaldo ("¿Estás seguro? (s/n)").
9. Crea una función `contar_archivos` que reciba un directorio como argumento y diga cuántos archivos contiene.
10. Crea un script `explorar.sh` que reciba un archivo CSV como argumento y muestre: número de filas, número de columnas, nombres de las columnas, y las primeras 3 filas de datos.
11. **Desafío 1**: Crea un script que reciba una extensión como argumento (ej: `txt`) y cuente cuántos archivos con esa extensión hay en el directorio actual y sus subdirectorios (usa `find`).
12. **Desafío 2**: Crea un mini-pipeline: un script que (1) cree un archivo CSV de prueba con datos inventados, (2) llame a otro script que cuente las filas y columnas, y (3) muestre un resumen final. Practica la coordinación entre scripts.
