import Callout from '../components/Callout.astro';
import CommandTable from '../components/CommandTable.astro';

En Linux, cada archivo y cada carpeta tiene **permisos** que determinan quién puede hacer qué con ellos. Esto es una de las bases de la seguridad del sistema: gracias a los permisos, otros usuarios no pueden leer tus archivos privados, los programas no pueden modificar archivos del sistema sin autorización, y tú mismo estás protegido de borrar cosas importantes por accidente.

Si vienes de Windows o macOS, probablemente nunca te has preocupado por permisos. En Linux, entenderlos es fundamental, especialmente cuando trabajas con scripts, servidores o datos sensibles. Al principio puede parecer complicado, pero en la práctica usarás los mismos patrones una y otra vez. Vamos paso a paso.

### Entender los permisos desde la terminal

#### Los tres tipos de permisos

Cada archivo o carpeta en Linux tiene tres permisos fundamentales. Es importante entender que **significan cosas distintas** dependiendo de si se aplican a un archivo o a una carpeta:

| Permiso | Letra | En un archivo | En una carpeta |
|---------|-------|---------------|----------------|
| **Lectura** | `r` | Puedes ver el contenido (abrirlo, copiarlo) | Puedes listar qué hay dentro (`ls`) |
| **Escritura** | `w` | Puedes modificar o sobreescribir el contenido | Puedes crear, renombrar o eliminar archivos dentro |
| **Ejecución** | `x` | Puedes ejecutarlo como programa o script | Puedes entrar a la carpeta con `cd` |

Veamos esto con ejemplos concretos para que quede claro:

- Un archivo con permiso `r` pero sin `w`: puedes leerlo, pero no editarlo. Imagina un documento de referencia que no quieres que nadie modifique.
- Un script `.sh` sin permiso `x`: aunque tenga código válido, la terminal te dirá "Permiso denegado" al intentar ejecutarlo. Necesitas darle `x` para que funcione.
- Una carpeta sin permiso `x`: no puedes ni entrar con `cd` ni acceder a los archivos de dentro, aunque tengas `r` para listarla. Es como tener la lista de contenido de una caja fuerte pero no la llave para abrirla.
- Una carpeta con `x` pero sin `r`: puedes entrar si conoces el nombre exacto de lo que buscas, pero no puedes listar su contenido. Es como una habitación oscura donde solo encuentras algo si sabes exactamente dónde está.

<Callout type="info" title="¿Por qué importa esto para ciencia de datos?">
  Cuando trabajas con datos, los permisos te ayudan a proteger información sensible (datos de pacientes, credenciales de bases de datos, API keys). Un archivo con permisos `600` significa que solo tú puedes leerlo. Esto no es opcional: muchas herramientas como SSH **se niegan a funcionar** si tus claves privadas tienen permisos demasiado abiertos.
</Callout>

#### Las tres categorías de usuarios

Los permisos se aplican a tres grupos de personas diferentes:

| Categoría | Letra | ¿Quién es? | Ejemplo |
|-----------|-------|-----------|---------|
| **Owner** | `u` | El dueño del archivo (generalmente quien lo creó) | Tú, cuando creas un script |
| **Group** | `g` | Un grupo de usuarios al que pertenece el archivo | Tu equipo de trabajo |
| **Others** | `o` | Todos los demás usuarios del sistema | Cualquier otra persona con acceso al servidor |

Esto significa que un archivo puede tener **permisos distintos para cada categoría**. Por ejemplo, tú (owner) puedes leer y editar un archivo, tu equipo (group) solo puede leerlo, y el resto (others) no puede ni verlo.

### Identificar permisos con `ls -l`

Esta es la habilidad más práctica: saber **leer** los permisos de cualquier archivo o carpeta. Cuando ejecutas `ls -l`, la primera columna muestra los permisos. Puede parecer críptico al principio, pero tiene una estructura muy clara:

```bash
ls -l mi-script.sh
# -rwxr-xr-- 1 paulo users 256 ene 15 10:30 mi-script.sh
```

Desglosemos esa cadena `-rwxr-xr--` carácter por carácter:

```
- rwx r-x r--
│ │   │   │
│ │   │   └── Others (otros): r-- = solo pueden leer
│ │   └────── Group (grupo):  r-x = pueden leer y ejecutar
│ └────────── Owner (dueño):  rwx = puede leer, escribir y ejecutar
└──────────── Tipo: - = archivo normal (d = directorio, l = enlace)
```

**El primer carácter** indica el tipo del elemento:
- `-` = archivo normal
- `d` = directorio (carpeta)
- `l` = enlace simbólico (un atajo a otro archivo)

**Los siguientes 9 caracteres** se leen en grupos de tres, siempre en el mismo orden: **r** (lectura), **w** (escritura), **x** (ejecución). Si hay un guión `-` en lugar de una letra, ese permiso está **desactivado**.

Veamos varios ejemplos para entrenar el ojo:

```bash
ls -l
# drwxr-xr-x  carpeta/          ← directorio: todos pueden entrar y listar
# -rw-r--r--  documento.txt     ← archivo: todos leen, solo el dueño edita
# -rwxr-xr-x  programa          ← ejecutable por todos
# -rw-------  clave-privada.pem ← archivo privado: SOLO el dueño accede
# drwx------  .ssh/             ← carpeta privada: solo el dueño puede entrar
# -rwxrwxrwx  peligroso.sh      ← ¡cualquiera puede modificar y ejecutar!
```

<Callout type="tip" title="Practica leyendo permisos">
  Ejecuta `ls -la` en tu directorio home y trata de leer los permisos de cada archivo. Identifica cuáles son carpetas (`d`), cuáles son privados (solo `rw` para el dueño), y cuáles son ejecutables (tienen `x`). Con práctica, leerás la cadena de permisos de un vistazo.
</Callout>

#### Otros datos que muestra `ls -l`

Además de los permisos, `ls -l` muestra información útil en cada columna:

```bash
-rwxr-xr-- 1 paulo users 256 ene 15 10:30 mi-script.sh
│           │ │     │     │   │              │
│           │ │     │     │   │              └── Nombre del archivo
│           │ │     │     │   └── Fecha de última modificación
│           │ │     │     └── Tamaño en bytes
│           │ │     └── Grupo propietario
│           │ └── Dueño (owner)
│           └── Número de enlaces
└── Permisos
```

Esto es especialmente útil para verificar **quién es el dueño** de un archivo y **cuándo fue modificado por última vez**.

### Modificar permisos con `chmod`

El comando `chmod` (de "**ch**ange **mod**e") es el que usarás para cambiar los permisos de archivos y carpetas. Hay dos formas de usarlo: el **modo simbólico** (con letras, más intuitivo) y el **modo octal** (con números, más rápido). Ambos hacen lo mismo, solo cambia la forma de expresarlo.

<Callout type="warning" title="Cuidado al cambiar permisos">
  Cambiar permisos incorrectamente puede tener consecuencias serias:

  - **Dar permisos excesivos** (`chmod 777`) a archivos sensibles expone datos privados a todos los usuarios del sistema.
  - **Quitar permisos de ejecución** a archivos del sistema puede dejar programas inutilizables.
  - **Cambiar permisos recursivamente** (`chmod -R`) en la carpeta equivocada puede afectar cientos de archivos de golpe.
  - **Nunca** ejecutes `chmod -R 777 /` — esto elimina todas las protecciones del sistema operativo completo.

  Regla de oro: da los **permisos mínimos necesarios**. Si solo tú necesitas leer un archivo, usa `600`, no `644`.
</Callout>

#### Modo simbólico (con letras)

El modo simbólico es el más fácil de entender porque usas letras que ya conoces. La sintaxis es:

```
chmod [quién][operación][permiso] archivo
```

**Quién:**
- `u` = owner (dueño)
- `g` = group (grupo)
- `o` = others (otros)
- `a` = all (todos, equivale a `u`, `g` y `o` juntos)

**Operación:**
- `+` = agregar un permiso
- `-` = quitar un permiso
- `=` = establecer permisos exactos (reemplaza los anteriores)

**Permiso:**
- `r` = lectura
- `w` = escritura
- `x` = ejecución

Veamos ejemplos prácticos:

```bash
# Dar permiso de ejecución al dueño
chmod u+x script.sh
# Antes: -rw-r--r--  →  Después: -rwxr--r--

# Quitar permiso de escritura a otros
chmod o-w archivo.txt
# Antes: -rw-r--rw-  →  Después: -rw-r--r--

# Dar lectura y ejecución al grupo
chmod g+rx programa
# Antes: -rwx------  →  Después: -rwxr-x---

# Dar permiso de ejecución a TODOS
chmod a+x script.sh
# Equivalente a: chmod u+x,g+x,o+x script.sh

# Establecer permisos EXACTOS para el dueño (reemplaza los anteriores)
chmod u=rw archivo.txt
# El dueño tendrá SOLO lectura y escritura, sin importar lo que tenía antes

# Quitar TODOS los permisos a otros
chmod o= secreto.txt
# Antes: -rw-r--r--  →  Después: -rw-r-----

# Combinación: dar todo al dueño, solo lectura al resto
chmod u=rwx,g=r,o=r programa
```

<Callout type="tip" title="El caso más común">
  La situación más frecuente es hacer un script ejecutable después de crearlo:

  ```bash
  chmod +x mi-script.sh
  ```

  Cuando no especificas quién (`u`/`g`/`o`), se aplica a todos. Este comando lo usarás constantemente al crear scripts de Bash.
</Callout>

#### Modo octal (con números)

El modo numérico es más rápido y es el estándar cuando necesitas establecer **todos los permisos de una sola vez**. Cada permiso tiene un valor numérico:

| Permiso | Valor |
|---------|-------|
| Lectura (`r`) | **4** |
| Escritura (`w`) | **2** |
| Ejecución (`x`) | **1** |
| Sin permiso | **0** |

Para calcular el número de cada categoría, **sumas los valores** de los permisos que quieres activar. Luego escribes tres dígitos: uno para el dueño, otro para el grupo y otro para otros.

Veamos un ejemplo paso a paso:

```
Queremos: rwxr-xr--

  Owner:  r + w + x = 4 + 2 + 1 = 7
  Group:  r + - + x = 4 + 0 + 1 = 5
  Others: r + - + - = 4 + 0 + 0 = 4

Resultado: chmod 754 archivo
```

Otro ejemplo, esta vez queremos que solo el dueño pueda leer y escribir:

```
Queremos: rw-------

  Owner:  r + w + - = 4 + 2 + 0 = 6
  Group:  - + - + - = 0 + 0 + 0 = 0
  Others: - + - + - = 0 + 0 + 0 = 0

Resultado: chmod 600 archivo
```

Esta es la tabla de combinaciones más útiles. No necesitas memorizar todas: con el tiempo las más comunes se vuelven automáticas:

| Número | Permisos | Significado |
|--------|----------|-------------|
| `7` | `rwx` | Todos los permisos |
| `6` | `rw-` | Lectura y escritura |
| `5` | `r-x` | Lectura y ejecución |
| `4` | `r--` | Solo lectura |
| `0` | `---` | Sin permisos |

Y los permisos completos más comunes que usarás en la práctica:

<CommandTable commands={[
  { command: "chmod 755 script.sh", description: "rwxr-xr-x — Scripts y programas: todos ejecutan, solo el dueño edita" },
  { command: "chmod 644 archivo.txt", description: "rw-r--r-- — Archivos normales: todos leen, solo el dueño edita" },
  { command: "chmod 700 carpeta/", description: "rwx------ — Carpeta privada: solo el dueño tiene acceso" },
  { command: "chmod 600 clave.pem", description: "rw------- — Archivo sensible: solo el dueño lee y escribe" },
  { command: "chmod 444 referencia.txt", description: "r--r--r-- — Solo lectura para todos (protección contra edición)" },
]} />

<Callout type="info" title="¿Cuál modo usar?">
  Para acciones simples como "hacer ejecutable", el modo simbólico es más fácil: `chmod +x script.sh`. Para establecer permisos exactos de una vez, el modo numérico es más preciso: `chmod 755 script.sh`. Con el tiempo usarás ambos según la situación.
</Callout>

#### Cambiar permisos en carpetas (modo recursivo)

Cuando cambias permisos de una carpeta, los archivos que están dentro **no cambian automáticamente**. Si quieres cambiar los permisos de una carpeta y todo lo que contiene, usas la opción `-R` (recursivo):

```bash
# Cambiar permisos de la carpeta Y todo lo de adentro
chmod -R 755 mi-proyecto/

# Hacer privada una carpeta y todo su contenido
chmod -R 700 datos-sensibles/
```

<Callout type="warning" title="Cuidado con chmod -R">
  El modo recursivo `-R` cambia permisos de **todos** los archivos y subcarpetas de golpe. Esto puede causar problemas:

  - Si aplicas `755` recursivamente, todos los archivos quedan como ejecutables (incluyendo `.txt`, `.csv`, etc.), lo cual no tiene sentido.
  - Si te equivocas de carpeta, puedes afectar archivos del sistema.

  Para aplicar permisos diferentes a archivos y carpetas, usa `find`:

  ```bash
  # Carpetas con 755 (se puede entrar y listar)
  find mi-proyecto/ -type d -exec chmod 755 {} \;

  # Archivos con 644 (se puede leer pero no ejecutar)
  find mi-proyecto/ -type f -exec chmod 644 {} \;
  ```
</Callout>

### La máscara de permisos: `umask`

Cuando creas un archivo nuevo, ¿qué permisos tiene por defecto? Eso lo controla el `umask`. La máscara define qué permisos se **quitan** automáticamente al crear archivos y carpetas nuevos.

```bash
# Ver tu máscara actual
umask
# Salida típica: 0022
```

El valor `0022` significa que a los archivos nuevos se les quita el permiso de escritura (`2`) para el grupo y para otros. En la práctica:

| Elemento | Permisos base | Menos umask `022` | Permisos reales |
|----------|--------------|-------------------|-----------------|
| Archivos | `666` (rw-rw-rw-) | - `022` | `644` (rw-r--r--) |
| Carpetas | `777` (rwxrwxrwx) | - `022` | `755` (rwxr-xr-x) |

Esto explica por qué cuando creas un archivo con `touch` te sale `rw-r--r--` y cuando creas una carpeta con `mkdir` te sale `rwxr-xr-x`.

<Callout type="tip" title="Puedes cambiar el umask">
  Si trabajas con datos sensibles y quieres que los archivos nuevos sean privados por defecto:

  ```bash
  # Solo el dueño puede leer y escribir archivos nuevos
  umask 077
  ```

  Esto solo afecta la sesión actual. Para hacerlo permanente, agrégalo a tu archivo `~/.bashrc`.
</Callout>

Las máscaras más comunes:

| umask | Archivos nuevos | Carpetas nuevas | Uso típico |
|-------|----------------|-----------------|------------|
| `022` | `644` (rw-r--r--) | `755` (rwxr-xr-x) | Valor por defecto en la mayoría de sistemas |
| `077` | `600` (rw-------) | `700` (rwx------) | Máxima privacidad |
| `002` | `664` (rw-rw-r--) | `775` (rwxrwxr-x) | Trabajo en equipo (grupo puede editar) |

### El superusuario: `sudo`

En Linux, hay tareas que solo puede hacer el **administrador** (también llamado **root** o superusuario): instalar programas, modificar archivos del sistema, gestionar servicios, cambiar permisos de archivos que no te pertenecen, etc.

El comando `sudo` (de "**S**uper **U**ser **DO**") te permite ejecutar **un solo comando** con privilegios de administrador:

```bash
# Actualizar la lista de paquetes disponibles
sudo apt update

# Instalar un programa
sudo apt install htop

# Editar un archivo de configuración del sistema
sudo nano /etc/hosts
```

Cuando usas `sudo`, el sistema te pedirá tu contraseña. Esto es una medida de seguridad para confirmar que realmente eres tú. La contraseña se "recuerda" por unos minutos, así que no te la pedirá de nuevo inmediatamente.

#### ¿Cuándo necesitas `sudo`?

La regla general es simple: necesitas `sudo` cuando quieres hacer algo **fuera de tu directorio home** o que afecta al sistema:

```bash
# Esto NO necesita sudo (es tu archivo, en tu carpeta)
chmod 755 ~/mi-script.sh
nano ~/notas.txt
mkdir ~/proyectos

# Esto SÍ necesita sudo (archivos del sistema o de otros usuarios)
sudo chmod 644 /etc/configuracion.conf
sudo chown usuario:grupo /opt/datos/
sudo apt install python3
```

<Callout type="warning" title="sudo es poder y responsabilidad">
  Con `sudo` puedes hacer **cualquier cosa** en el sistema, incluyendo destruirlo completamente. Algunas reglas de supervivencia:

  - **Nunca** ejecutes `sudo rm -rf /` ni variantes como `sudo rm -rf /*` — borra todo el sistema operativo.
  - **Nunca** copies comandos con `sudo` de internet sin entender qué hacen primero. Un comando malicioso con `sudo` puede instalar software dañino o borrar tus datos.
  - **Nunca** uses `sudo chmod -R 777 /` — elimina todas las protecciones de seguridad del sistema completo.
  - Si un comando no funciona sin `sudo`, pregúntate **por qué** necesita permisos de administrador antes de agregarlo. Muchas veces el problema real es otro (ruta incorrecta, archivo inexistente, etc.).
  - **Nunca** trabajes permanentemente como root (`sudo su`). Usa `sudo` solo para comandos específicos.
</Callout>

#### Relación entre permisos y `sudo`

Aquí es donde todo se conecta. Los permisos definen qué puedes hacer **como usuario normal**. Cuando los permisos te bloquean, tienes dos opciones:

1. **Cambiar los permisos** (si el archivo es tuyo): `chmod +x mi-script.sh`
2. **Usar `sudo`** (si el archivo no es tuyo o es del sistema): `sudo nano /etc/hosts`

```bash
# Intentas editar un archivo del sistema
nano /etc/hostname
# Error: permiso denegado (no eres root)

# Opción correcta: usar sudo para ese comando específico
sudo nano /etc/hostname
```

Un truco útil: si olvidaste poner `sudo` al inicio de un comando y te dio error de permisos, puedes ejecutar `sudo !!` para repetir el último comando con `sudo`:

```bash
apt update
# Error: permiso denegado

sudo !!
# Equivale a: sudo apt update
```

### Cambiar propietario con `chown`

El comando `chown` (de "**ch**ange **own**er") cambia quién es el dueño de un archivo o carpeta. Siempre necesitas `sudo` para usarlo (salvo que estés cediendo algo que ya es tuyo):

```bash
# Cambiar solo el dueño
sudo chown maria archivo.txt

# Cambiar dueño y grupo a la vez
sudo chown maria:equipo-datos archivo.txt

# Cambiar recursivamente (carpeta y todo lo de adentro)
sudo chown -R maria:equipo-datos proyecto/
```

¿Cuándo necesitas `chown`? Principalmente cuando:

- Descargas archivos que quedaron con un dueño incorrecto
- Configuras carpetas compartidas en un servidor
- Mueves archivos entre usuarios

```bash
# Ver quién es el dueño actual
ls -l datos.csv
# -rw-r--r-- 1 root root 1024 ene 15 10:30 datos.csv
#               ↑    ↑
#            dueño  grupo → ¡El dueño es root! No puedes editarlo

# Cambiarlo a tu usuario
sudo chown paulo:paulo datos.csv

# Ahora puedes editarlo sin sudo
nano datos.csv  # ¡Funciona!
```

### Resumen visual de comandos

<CommandTable commands={[
  { command: "ls -l", description: "Ver permisos, dueño, grupo y tamaño de archivos" },
  { command: "ls -la", description: "Igual pero incluyendo archivos ocultos" },
  { command: "chmod +x archivo", description: "Hacer un archivo ejecutable" },
  { command: "chmod 755 archivo", description: "Permisos rwxr-xr-x (script/programa)" },
  { command: "chmod 644 archivo", description: "Permisos rw-r--r-- (archivo normal)" },
  { command: "chmod 600 archivo", description: "Permisos rw------- (archivo privado)" },
  { command: "chmod -R 700 carpeta/", description: "Permisos solo para el dueño, recursivamente" },
  { command: "umask", description: "Ver la máscara de permisos por defecto" },
  { command: "sudo comando", description: "Ejecutar un comando como administrador" },
  { command: "sudo !!", description: "Repetir el último comando con sudo" },
  { command: "sudo chown usuario archivo", description: "Cambiar el dueño de un archivo" },
  { command: "sudo chown -R usuario:grupo carpeta/", description: "Cambiar dueño y grupo recursivamente" },
]} />

### Ejercicios del módulo

1. Ejecuta `ls -la` en tu directorio home. Observa la columna de permisos. Identifica al menos un directorio (`d`), un archivo oculto (empieza con `.`), y un archivo con permisos restrictivos.
2. Crea un archivo `secreto.txt` con `echo "datos confidenciales" > secreto.txt`. Verifica sus permisos con `ls -l secreto.txt`. ¿Qué permisos tiene por defecto?
3. Quita todos los permisos a otros usuarios: `chmod o-rwx secreto.txt`. Verifica con `ls -l`. ¿Cómo cambió la cadena de permisos?
4. Ahora ponle permisos `600` (solo dueño lee y escribe): `chmod 600 secreto.txt`. Verifica con `ls -l`. ¿Ves la diferencia con el paso anterior?
5. Crea un script: `echo '#!/bin/bash' > script-test.sh && echo 'echo "funciona"' >> script-test.sh`. Intenta ejecutarlo con `./script-test.sh`. ¿Qué error te da y por qué?
6. Dale permisos de ejecución con `chmod +x script-test.sh`. Ahora ejecútalo de nuevo. ¿Funciona? Verifica con `ls -l` que la `x` apareció.
7. Usa `chmod 755 script-test.sh` y verifica con `ls -l`. Luego usa `chmod 700 script-test.sh`. ¿Cuál es la diferencia entre ambos?
8. Ejecuta `umask` para ver tu máscara actual. Luego crea un archivo con `touch nuevo.txt` y una carpeta con `mkdir nueva-carpeta`. Verifica los permisos de ambos con `ls -l`. ¿Coinciden con lo que el `umask` predice?
9. Intenta editar `/etc/hostname` con `nano /etc/hostname` (sin sudo). ¿Qué pasa? Ahora intenta con `sudo nano /etc/hostname` (pero sal sin guardar con `Ctrl + X` y luego `N`).
10. Ejecuta `sudo whoami`. ¿Qué usuario aparece? Compara con `whoami` sin sudo. Esto demuestra que `sudo` te convierte temporalmente en root.
11. **Desafío 1**: Calcula el número octal para los permisos `rwxr--r--`. Crea un archivo y aplica esos permisos. Verifica con `ls -l`.
12. **Desafío 2**: Crea una carpeta `proyecto/` con tres archivos dentro. Usa `find` con `-exec chmod` para poner las carpetas en `755` y los archivos en `644`. Verifica con `ls -lR`.
